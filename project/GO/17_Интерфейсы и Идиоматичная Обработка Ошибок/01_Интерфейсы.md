Интерфейс в Go — это набор сигнатур методов. Он определяет, **что** тип должен уметь делать, но не говорит, **как** он это делает.

* **Определение интерфейса:**
```go
// Любой тип, который хочет быть "Писателем" (Writer),
// должен иметь метод Write, принимающий слайс байт и возвращающий
// количество записанных байт и ошибку.
type Writer interface {
	Write(p []byte) (n int, err error)
}
```

Это реальный интерфейс `io.Writer` из стандартной библиотеки — один из самых важных в Go.

* **Неявная реализация (Утиная типизация):**
Это **ключевое отличие** Go от языков вроде Java или C#. В Go не нужно явно указывать, что ваш тип реализует интерфейс (никаких `implements Writer`). Тип **автоматически** удовлетворяет интерфейсу, если у него есть все методы из этого интерфейса с точно такими же сигнатурами.

*Аналогия:* Если нечто выглядит как утка, плавает как утка и крякает как утка, то это, вероятно, и есть утка. Если ваш тип имеет метод `Write(...)`, то он является `Writer`.

* **Пример реализации:**
```go
import "fmt"

// Создадим свой тип, который будет писать в консоль.
type ConsoleWriter struct{}

// Реализуем метод Write для ConsoleWriter.
// Теперь ConsoleWriter *неявно* удовлетворяет интерфейсу io.Writer.
func (cw ConsoleWriter) Write(p []byte) (n int, err error) {
	// fmt.Print возвращает количество байт и ошибку, что идеально подходит.
	return fmt.Print(string(p))
}

func main() {
	// Создаем экземпляр нашего типа
	var writer ConsoleWriter
	// Вызываем метод напрямую
	writer.Write([]byte("Привет, мир!\n"))
}
```

* **Полиморфизм через интерфейсы:**
Самая большая сила интерфейсов — в создании функций, которые могут работать с
любым типом, реализующим этот интерфейс.
```go
import (
	"fmt"
	"os" // os.Stdout также реализует io.Writer!
)

// Эта функция не знает, что такое ConsoleWriter или os.File.
// Она знает только, что ей передали нечто, что умеет "писать" (имеет метод Write).
func greet(writer Writer) {
	writer.Write([]byte("Hello from the greet function!\n"))
}

func main() {
	// 1. Используем наш собственный тип
	myWriter := ConsoleWriter{}
	greet(myWriter) // Работает!
	// 2. Используем тип из стандартной библиотеки
	// os.Stdout - это стандартный вывод (консоль), и он реализует io.Writer
	greet(os.Stdout) // Тоже работает!
}
```

Мы написали одну функцию `greet`, которая может работать с бесконечным количеством
разных типов "писателей", даже с теми, которые будут созданы в будущем, пока они
соблюдают "контракт" интерфейса `Writer`.

* **Пустой интерфейс `interface{}` (или `any`):**
`interface{}` — это интерфейс без методов. Раз у него нет методов, то ему удовлетворяет
**абсолютно любой тип**.
С Go 1.18 был добавлен псевдоним `any` для `interface{}`, что делает код более читаемым.
```go
func printAnything(v any) {
	fmt.Println(v)
}
printAnything(42)
printAnything("hello")
printAnything(ConsoleWriter{})
```

*Использование:* Пустой интерфейс — это "аварийный люк" для работы с данными
неизвестного типа. Он полезен, но лишает вас статической проверки типов. Его следует
использовать с осторожностью.* **Приведение типов (Type Assertion):**
Чтобы "достать" конкретный тип из-под `interface{}`, используется приведение типов.
```go
var i any = "hello"
// Способ 1: Прямое приведение. Если тип не тот - будет паника!
s := i.(string)
fmt.Println(s)
// Способ 2: Безопасное приведение с проверкой.
val, ok := i.(int)
if ok {
	fmt.Println("i - это int со значением", val)
} else {
	fmt.Println("i - это не int") // Этот блок выполнится
}
```