Слайс — это гибкое и мощное представление непрерывной последовательности элементов [[wiki/project/GO/15_Типы данных/01_Массивы|массива]]. В отличие от [[wiki/project/GO/15_Типы данных/01_Массивы|массива]], слайс не хранит данные напрямую. Это "обертка" или "вид" на часть существующего массива.

* **Внутреннее устройство (три кита слайса):** Каждый заголовок слайса (slice header) содержит три поля:

1. **Указатель (Pointer):** Адрес первого элемента в *базовом массиве* (underlying array), на который смотрит слайс.
2. **Длина (Length / `len`):** Количество элементов, доступных в слайсе. `len(mySlice)`.
3. **Ёмкость (Capacity / `cap`):** Количество элементов в базовом массиве, начиная от указателя слайса и до конца массива. `cap(mySlice)`. Ёмкость показывает, на сколько можно "вырастить" слайс, прежде чем понадобится аллоцировать новый массив.

*Аналогия:* Представьте книгу (базовый массив). Слайс — это закладка (указатель) с
запиской: "Читать 3 главы (длина), всего в книге до конца осталось 10 глав (ёмкость)".

* **Создание слайсов:**
```go
// Литерал (самый частый способ). Go сам создаст под капотом массив.
s1 := []string{"a", "b", "c"} // len=3, cap=3
// С помощью `make`. Идеально, когда вы знаете нужный размер заранее.
// make([]T, length, capacity)
s2 := make([]int, 5) // len=5, cap=5, заполнен нулями
s3 := make([]int, 0, 10) // len=0, cap=10. Эффективный способ для последующего заполнения
// `nil` слайс. Нулевое значение для слайса.
var s4 []int // len=0, cap=0, указатель равен nil. Готов к использованию.
```

* **Операция `append` — ключ к динамике:**`append` добавляет элементы в конец слайса и возвращает **новый** слайс.
```go
s := []int{1, 2, 3} // len=3, cap=3
s = append(s, 4) // Что произошло под капотом?
// 1. Места в базовом массиве не хватило (len стал > cap).
// 2. Go создал НОВЫЙ, более длинный массив (обычно в 2 раза больше).
// 3. Скопировал элементы {1, 2, 3} в новый массив.
// 4. Добавил {4}.
// 5. Вернул слайс, указывающий на этот НОВЫЙ массив.
// Теперь s: len=4, cap=6 (или около того)
```

**Золотое правило:** Всегда переприсваивайте результат `append`: `mySlice = append(mySlice, newValue)`.

* **Срезы (Slicing): Создание новых видов на старые данные**
`slice[low:high]` — создает новый заголовок слайса, который смотрит на тот же базовый массив.
```go
letters := []string{"a", "b", "c", "d", "e"} // len=5, cap=5
// Создаем новый слайс, указывающий на элементы с индекса 1 до 3 (не включая 3)
sub1 := letters[1:3] // {"b", "c"}. len=2, cap=4 (от "b" до конца "e")
// Изменение данных через один слайс видно в другом!
sub1[0] = "X"
fmt.Println(letters) // Выведет: [a X c d e]
```